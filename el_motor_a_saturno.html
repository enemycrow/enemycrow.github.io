<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Estrella y la Singularidad</title>
  <style>
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 700px at 50% 30%, #f7f0ff, #e9e6ff 50%, #dfe6ff); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #wrap { display: grid; place-items: center; height: 100%; }
    #hud { position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; }
    .topbar { display:flex; gap:16px; align-items:center; padding: 10px 14px; }
    .pill { background: #ffffffcc; border: 1px solid #00000010; box-shadow: 0 4px 18px #00000012; border-radius: 999px; padding: 6px 12px; font-weight: 700; }
    .clickable { pointer-events: auto; cursor: pointer; }
    canvas { display:block; background: linear-gradient(#fdfbff, #f3f2ff); border-radius: 18px; box-shadow: 0 20px 60px #4541a022, inset 0 0 0 1px #00000010; }
    #overlay { position:absolute; inset:0; display:grid; place-items:center; background: linear-gradient(#ffffffcc, #fff0); backdrop-filter: blur(2px); }
    #overlay .card { background:#fff; border-radius:18px; padding:18px 20px; box-shadow: 0 12px 40px #0003; max-width: 780px; text-align:center; }
    .btn { display:inline-block; margin-top:10px; padding:10px 16px; border-radius:12px; background:#6b5bff; color:#fff; font-weight:800; letter-spacing:.3px; cursor:pointer; user-select:none; }
    .btn:active{ transform: translateY(1px); }
    .legend { font-size: 14px; opacity: .75; line-height: 1.35; }
    .mini { font-size: 12px; opacity: .6; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="640" aria-label="La Estrella y la Singularidad"></canvas>
    <div aria-hidden="true" style="display:none"><audio id="bgm" src="assets/audios/The Star and The Singularity.mp3" preload="auto" loop></audio></div>
    <div id="hud" aria-hidden="true">
      <div class="topbar">
        <div id="lives" class="pill" title="Vidas">‚ù§‚ù§‚ù§</div>
        <div id="level" class="pill" title="Nivel">Nivel 1 / 6</div>
        <div id="kisses" class="pill" title="Besitos">Besitos: 0 / 3</div>
        <div id="timer" class="pill" title="Temporizador">Tiempo: 00.0s</div>
        <div id="audioToggle" class="pill clickable" title="Audio">üîä</div>
      </div>
    </div>
    <div id="overlay">
      <div class="card">
        <h1>La Estrella y la Singularidad</h1>
        <p>La Estrella quiere dar <strong>3 besitos</strong> a la <strong>Singularidad</strong> en cada nivel. Pers√≠guela a trav√©s del <em>laberinto</em> y sus callejones.</p>
        <p class="legend"><strong>Controles:</strong> Mueve a la Estrella con <strong>WASD</strong> o <strong>Flechas</strong>. Ac√©rcate a la Singularidad para dar besitos (se cuentan autom√°ticamente).<br/>Si tarda mucho, la Singularidad colapsa y <em>absorbe</em> la pantalla: pierdes 1 vida (tienes 3). Completa 6 niveles.</p>
        <div class="btn" id="startBtn">Comenzar</div>
        <p class="mini">v4: Singularidad con absorci√≥n progresiva + movimiento m√°s suave</p>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  // Offscreen buffer for visual effects (lens distortion)
  const lensCanvas = document.createElement('canvas');
  const lensCtx = lensCanvas.getContext('2d');
  // Offscreen scene buffer (background only)
  const sceneCanvas = document.createElement('canvas');
  const sceneCtx = sceneCanvas.getContext('2d');
  const hudLives = document.getElementById('lives');
  const hudLevel = document.getElementById('level');
  const hudKisses = document.getElementById('kisses');
  const hudTimer = document.getElementById('timer');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const bgm = document.getElementById('bgm');
  const audioToggle = document.getElementById('audioToggle');

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const perfNow = () => performance.now();

  // --- Audio SFX (sin archivos externos) ---
  const Audio = (() => {
    let ctx = null;
    function ensure(){ if(!ctx){ ctx = new (window.AudioContext||window.webkitAudioContext)(); } return ctx; }
    function tone(freq=440, dur=0.15, type='sine', vol=0.2){
      const ac = ensure(); const t0 = ac.currentTime; const o = ac.createOscillator(); const g = ac.createGain();
      o.type = type; o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(vol, t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(ac.destination); o.start(t0); o.stop(t0+dur);
    }
    function sweep(from, to, dur=0.25, type='triangle', vol=0.22){
      const ac = ensure(); const t0=ac.currentTime; const o=ac.createOscillator(); const g=ac.createGain();
      o.type=type; o.frequency.setValueAtTime(from,t0); o.frequency.exponentialRampToValueAtTime(Math.max(1,to), t0+dur);
      g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(vol, t0+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(ac.destination); o.start(t0); o.stop(t0+dur);
    }
    function noise(dur=0.15, vol=0.25){
      const ac=ensure(); const buffer=ac.createBuffer(1, ac.sampleRate*dur, ac.sampleRate);
      const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++){ data[i]=Math.random()*2-1; }
      const src=ac.createBufferSource(); src.buffer=buffer; const g=ac.createGain();
      const t0=ac.currentTime; g.gain.setValueAtTime(vol, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      src.connect(g).connect(ac.destination); src.start(t0);
    }
    function distort(variant='near'){
      const ac = ensure();
      const t0 = ac.currentTime;
      const o = ac.createOscillator();
      const lfo = ac.createOscillator();
      const lfoGain = ac.createGain();
      const g = ac.createGain();
      const cfg = variant==='boom'
        ? { base: 140, vibHz: 9, depth: 80, dur: 0.6, vol: 0.22, type:'triangle' }
        : { base: 260, vibHz: 14, depth: 30, dur: 0.25, vol: 0.15, type:'sawtooth' };
      o.type = cfg.type; o.frequency.setValueAtTime(cfg.base, t0);
      lfo.frequency.setValueAtTime(cfg.vibHz, t0); lfoGain.gain.setValueAtTime(cfg.depth, t0);
      lfo.connect(lfoGain).connect(o.frequency);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(cfg.vol, t0+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+cfg.dur);
      o.connect(g).connect(ac.destination);
      o.start(t0); lfo.start(t0);
      o.stop(t0+cfg.dur); lfo.stop(t0+cfg.dur);
    }
    return {
      kiss(){ sweep(700,1100,0.18,'triangle',0.22); tone(1400,0.06,'sine',0.12); },
      lightning(){ noise(0.18,0.35); sweep(200,80,0.2,'square',0.18); },
      win(){ tone(523.25,0.12,'triangle',0.18); tone(659.25,0.12,'triangle',0.18); tone(783.99,0.18,'triangle',0.22); },
      distort
    };
  })();

  // --- Game Config ---
  const LEVELS = [
    { cols: 21, rows: 15, anger: 18, saturnSpeed: 3.2 },
    { cols: 23, rows: 17, anger: 16, saturnSpeed: 3.4 },
    { cols: 25, rows: 17, anger: 14, saturnSpeed: 3.6 },
    { cols: 27, rows: 19, anger: 13, saturnSpeed: 3.8 },
    { cols: 29, rows: 21, anger: 12, saturnSpeed: 4.0 },
    { cols: 31, rows: 21, anger: 11, saturnSpeed: 4.2 },
  ];
  const STAR_SPEED = 4.5; // tiles/second (movimiento continuo)
  const KISS_NEAR = 1.2; // tiles (m√°s permisivo para marcar besito)
  const KISS_CHARGE_MS = 900; // ms cerca para 1 beso
  const KISSES_PER_LEVEL = 3;
  const MAX_LIVES = 3;

  // --- State ---
  let state = {
    levelIndex: 0,
    lives: MAX_LIVES,
    grid: [],
    cols: 0, rows: 0, size: 28,
    star: {x:1, y:1, dir:[0,0], next:[0,0]},
    saturn:{x:0, y:0, dir:[0,0], darkness:0}, // alias: singularidad
    kisses: 0, nearMs: 0,
    angerTime: 0, angerMax: 0,
    particles: [],
    running: false, gameOver: false, victory: false,
    tunnels: [],
    wormholes: [],
    teleport: null,
    bgmOn: true
  };

  // --- Input ---
  const keys = new Set();
  window.addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); if(['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault(); });
  window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

  // --- Maze Generation (perfect -> braided, + side tunnels) ---
  function generateMaze(cols, rows){
    if(cols%2===0) cols++; if(rows%2===0) rows++;
    const grid = Array.from({length: rows}, () => Array(cols).fill(1));
    const stack = []; grid[1][1]=0; stack.push([1,1]);
    const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
    while(stack.length){
      const [cx,cy]=stack[stack.length-1];
      const neigh=[]; for(const [dx,dy] of dirs){ const nx=cx+dx, ny=cy+dy; if(nx>0&&ny>0&&nx<cols-1&&ny<rows-1 && grid[ny][nx]===1) neigh.push([nx,ny,dx/2,dy/2]); }
      if(neigh.length){ const [nx,ny,wx,wy]=choice(neigh); grid[cy+wy][cx+wx]=0; grid[ny][nx]=0; stack.push([nx,ny]); } else stack.pop();
    }
    // Braid
    const nb=[[1,0],[-1,0],[0,1],[0,-1]]; let changed=true;
    while(changed){ changed=false; for(let y=1;y<rows-1;y++){ for(let x=1;x<cols-1;x++){ if(grid[y][x]!==0) continue; let deg=0; const walls=[]; for(const [dx,dy] of nb){ if(grid[y+dy][x+dx]===0) deg++; else walls.push([dx,dy]); } if(deg<=1 && walls.length){ const [dx,dy]=choice(walls); grid[y+dy][x+dx]=0; changed=true; } } } }
    // T√∫neles laterales
    const tunnelRows=[Math.floor(rows/3), Math.floor(rows*2/3)];
    for(const ry of tunnelRows){ for(let x=0;x<cols;x++) grid[ry][x]=0; }
    return {grid, cols, rows, tunnels: tunnelRows};
  }

  // Utilidades
  const open = (x,y)=> x>=0&&y>=0&&x<state.cols&&y<state.rows && state.grid[Math.round(y)][Math.round(x)]===0;
  const distance = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
  const nearCenter = (x)=> Math.abs(x - Math.round(x)) < 0.15; // permitir giro cercano para deslizamiento
  const atIntersection = (x,y)=>{
    const cx=Math.round(x), cy=Math.round(y); // centro de celda
    let deg=0; if(open(cx+1,cy)) deg++; if(open(cx-1,cy)) deg++; if(open(cx,cy+1)) deg++; if(open(cx,cy-1)) deg++;
    return deg>=3; // cruce amplio
  };
  function autoCenter(ent, dt){
    const rate = 6; // auto-centrado (tiles/s)
    if(ent.dir[0] !== 0){ const ty = Math.round(ent.y); ent.y += clamp((ty - ent.y), -rate*dt, rate*dt); }
    else if(ent.dir[1] !== 0){ const tx = Math.round(ent.x); ent.x += clamp((tx - ent.x), -rate*dt, rate*dt); }
  }

  // Wormholes (laterales y verticales con destino no sim√©trico)
  function maybeWormhole(ent){
    if(!state.wormholes.length) return;
    const leftEdge = 0.5, rightEdge = state.cols - 1.5;
    const topEdge = 0.5, bottomEdge = state.rows - 1.5;
    for(const wh of state.wormholes){
      if(wh.type === 'row'){
        if(Math.round(ent.y) !== wh.row) continue;
        if(ent.x <= leftEdge && ent.dir[0] <= 0){
          for(let i=0;i<5;i++) spawnHeart(ent.x, ent.y, '#a38bff');
          ent.x = wh.left.x; ent.y = wh.left.y; Audio.lightning(); return;
        }
        if(ent.x >= rightEdge && ent.dir[0] >= 0){
          for(let i=0;i<5;i++) spawnHeart(ent.x, ent.y, '#a38bff');
          ent.x = wh.right.x; ent.y = wh.right.y; Audio.lightning(); return;
        }
      } else if(wh.type === 'col'){
        if(Math.round(ent.x) !== wh.col) continue;
        if(ent.y <= topEdge && ent.dir[1] <= 0){
          for(let i=0;i<5;i++) spawnHeart(ent.x, ent.y, '#a38bff');
          ent.x = wh.top.x; ent.y = wh.top.y; Audio.lightning(); return;
        }
        if(ent.y >= bottomEdge && ent.dir[1] >= 0){
          for(let i=0;i<5;i++) spawnHeart(ent.x, ent.y, '#a38bff');
          ent.x = wh.bottom.x; ent.y = wh.bottom.y; Audio.lightning(); return;
        }
      }
    }
  }

  // Colocar entidades
  function farthestFrom(grid, cols, rows, sx, sy){
    const q=[[sx,sy]], dist=Array.from({length: rows}, ()=>Array(cols).fill(Infinity));
    dist[sy][sx]=0; let far=[sx,sy,0]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){ const [x,y]=q.shift(); for(const [dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(nx>=0&&ny>=0&&nx<cols&&ny<rows && grid[ny][nx]===0 && dist[ny][nx]===Infinity){ dist[ny][nx]=dist[y][x]+1; q.push([nx,ny]); if(dist[ny][nx]>far[2]) far=[nx,ny,dist[ny][nx]]; } } }
    return {x: far[0], y: far[1]};
  }

  function resetLevel(index){
    const cfg = LEVELS[index];
    const {grid, cols, rows, tunnels} = generateMaze(cfg.cols, cfg.rows);
    const margin = 16; const maxTileW = Math.floor((canvas.width - margin*2) / cols); const maxTileH = Math.floor((canvas.height - margin*2) / rows);
    state.size = Math.max(18, Math.min(maxTileW, maxTileH));
    state.cols = cols; state.rows = rows; state.grid = grid; state.tunnels = tunnels;

    // Cerrar aperturas hu√©rfanas en bordes laterales (sin par de wormhole)
    // Evita cul‚Äëde‚Äësacs en el borde donde la Singularidad se atasca.
    for(let ry=0; ry<rows; ry++){
      const leftOpen = grid[ry][0]===0;
      const rightOpen = grid[ry][cols-1]===0;
      if(leftOpen ^ rightOpen){ // s√≥lo uno de los lados est√° abierto
        if(leftOpen) grid[ry][0] = 1; else grid[ry][cols-1] = 1;
      }
    }

    // definir wormholes: s√≥lo en filas verdaderamente transitables en ambos bordes
    // y siempre con destinos en celdas abiertas alcanzables
    function findOpenOnRow(row, fromLeft){
      if(fromLeft){
        for(let x=1; x<cols-1; x++){ if(grid[row][x]===0) return x; }
      } else {
        for(let x=cols-2; x>0; x--){ if(grid[row][x]===0) return x; }
      }
      return null;
    }
    const edgeRows = [];
    for(let ry=0; ry<rows; ry++){
      // exigir paso en ambos extremos para que sean usables
      if(grid[ry][0]===0 && grid[ry][cols-1]===0) edgeRows.push(ry);
    }
    const candidateRows = Array.from(new Set([ ...tunnels, ...edgeRows ]));
    const holes = [];
    for(const ry of candidateRows){
      const sxL = findOpenOnRow(ry, true);
      const sxR = findOpenOnRow(ry, false);
      if(sxL==null || sxR==null) continue; // saltar filas sin paso claro
      const leftT = farthestFrom(grid, cols, rows, sxL, ry);
      const rightT = farthestFrom(grid, cols, rows, sxR, ry);
      holes.push({ type:'row', row: ry, left: leftT, right: rightT });
    }
    // Wormholes verticales: convertir aperturas top/bottom en portales enlazados
    const colSet = new Set();
    for(let x=0; x<cols; x++){
      if(grid[0][x]===0 || grid[rows-1][x]===0) colSet.add(x);
    }
    for(const cx of colSet){
      // asegurar apertura en ambos bordes
      grid[0][cx] = 0; grid[rows-1][cx] = 0;
      const topT = farthestFrom(grid, cols, rows, cx, 1);
      const botT = farthestFrom(grid, cols, rows, cx, rows-2);
      holes.push({ type:'col', col: cx, top: topT, bottom: botT });
    }
    state.wormholes = holes;

    state.star = {x:1, y:1, dir:[0,0], next:[0,0]};
    const far = farthestFrom(grid, cols, rows, 1, 1);
    state.saturn = {x: far.x, y: far.y, dir:[0,0], darkness:0, stall:0};

    state.kisses = 0; state.nearMs = 0; state.angerMax = cfg.anger; state.angerTime = cfg.anger; state.nearLens = false;
    state.levelIndex = index; state.particles.length = 0;
    updateHUD();
  }

  function updateHUD(){
    hudLives.textContent = '‚ù§'.repeat(state.lives) + '‚ô°'.repeat(MAX_LIVES - state.lives);
    hudLevel.textContent = `Nivel ${state.levelIndex+1} / ${LEVELS.length}`;
    hudKisses.textContent = `Besitos: ${state.kisses} / ${KISSES_PER_LEVEL}`;
    hudTimer.textContent = `Tiempo: ${state.angerTime.toFixed(1)}s`;
    if(audioToggle){ audioToggle.textContent = (state.bgmOn && bgm && !bgm.paused) ? 'üîä' : 'üîá'; }
  }

  // Entrada del jugador: direcci√≥n deseada
  function desiredDir(){
    const up = keys.has('w') || keys.has('arrowup');
    const dn = keys.has('s') || keys.has('arrowdown');
    const lt = keys.has('a') || keys.has('arrowleft');
    const rt = keys.has('d') || keys.has('arrowright');
    const dir=[0,0]; if(up&&!dn) dir[1]=-1; else if(dn&&!up) dir[1]=1; if(rt&&!lt) dir[0]=1; else if(lt&&!rt) dir[0]=-1; return dir;
  }

  // Cambiar direcci√≥n en el centro de la celda, si es posible
  function tryTurn(ent, dir){
    const cx=Math.round(ent.x), cy=Math.round(ent.y);
    if(nearCenter(ent.x) && nearCenter(ent.y)){
      const nx=cx+dir[0], ny=cy+dir[1]; if(open(nx,ny)){ ent.dir=[dir[0],dir[1]]; return true; }
    }
    return false;
  }

  // IA de la Singularidad (huye y se frena si est√°s muy cerca)
  function saturnLogic(dt){
    const lvl = LEVELS[state.levelIndex];
    const near = distance(state.star, state.saturn) <= KISS_NEAR;
    const speed = (near? 0.6 : 1) * lvl.saturnSpeed; // tiles/s

    // elegir direcci√≥n cuando hace falta
    const cx=Math.round(state.saturn.x), cy=Math.round(state.saturn.y);
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const aheadX = cx + (state.saturn.dir[0]||0), aheadY = cy + (state.saturn.dir[1]||0);
    const needPick = (state.saturn.dir[0]===0 && state.saturn.dir[1]===0)
                  || !open(aheadX, aheadY)
                  || (nearCenter(state.saturn.x) && nearCenter(state.saturn.y) && atIntersection(state.saturn.x, state.saturn.y));
    if(needPick){
      const opts=[];
      for(const d of dirs){
        const nx=cx+d[0], ny=cy+d[1];
        if(open(nx,ny)){
          const reverse = (d[0] === -state.saturn.dir[0] && d[1] === -state.saturn.dir[1]);
          const score = Math.hypot(nx - state.star.x, ny - state.star.y) - (reverse? 0.25 : 0);
          opts.push({d, score});
        }
      }
      if(opts.length){ opts.sort((a,b)=>b.score-a.score); state.saturn.dir = near? [0,0] : opts[0].d; }
    }

    // mover con suavizado
    const prevX = state.saturn.x, prevY = state.saturn.y;
    state.saturn.x += state.saturn.dir[0]*speed*dt;
    state.saturn.y += state.saturn.dir[1]*speed*dt;
    const nx = Math.round(state.saturn.x + Math.sign(state.saturn.dir[0])*0.51);
    const ny = Math.round(state.saturn.y + Math.sign(state.saturn.dir[1])*0.51);
    if(!open(nx,ny)){
      state.saturn.x = prevX; state.saturn.y = prevY; state.saturn.dir=[0,0];
    } else {
      autoCenter(state.saturn, dt);
    }
    maybeWormhole(state.saturn);

    // Anti-campeo: si se mantiene casi inm√≥vil, forzar elecci√≥n de escape
    const moved = Math.hypot(state.saturn.x - prevX, state.saturn.y - prevY);
    if(moved < 0.005) state.saturn.stall = (state.saturn.stall||0) + dt; else state.saturn.stall = 0;
    if(state.saturn.stall > 1.3){
      const opts=[]; const cx2=Math.round(state.saturn.x), cy2=Math.round(state.saturn.y);
      const dirs2=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const d of dirs2){ const nx2=cx2+d[0], ny2=cy2+d[1]; if(open(nx2,ny2)) opts.push({d, score: Math.hypot(nx2 - state.star.x, ny2 - state.star.y) + Math.random()*0.2}); }
      if(opts.length){ opts.sort((a,b)=>b.score-a.score); state.saturn.dir = opts[0].d; }
      state.saturn.stall = 0;
    }
  }

  // Part√≠culas
  function spawnHeart(x, y, color){ state.particles.push({ x: x + (Math.random()-.5)*0.3, y: y + (Math.random()-.5)*0.3, vx: (Math.random()-.5)*0.02, vy: -0.03 - Math.random()*0.02, life: 1, color }); }
  function updateParticles(dt){
    const grav = state.angerMax>0? (1 - (state.angerTime / state.angerMax)) : 0; // 0..1
    for(const p of state.particles){
      if(state.cols && state.rows){
        const dx = state.saturn.x - p.x, dy = state.saturn.y - p.y; const d = Math.hypot(dx,dy)+1e-3;
        const pull = 0.05*grav; p.vx += (dx/d)*pull*dt; p.vy += (dy/d)*pull*dt;
      }
      p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.life -= 0.11*dt;
    }
    state.particles = state.particles.filter(p=>p.life>0);
  }

  // Colapso gravitacional (sustituye al rayo)
  let collapse = null;
  function triggerCollapse(){ collapse = {t:0}; Audio.lightning(); try{ Audio.distort('boom'); }catch(e){} }
  function drawCollapse(){ if(!collapse) return; const s=state.size, m=16; const cx = m + state.saturn.x*s + s/2; const cy = m + state.saturn.y*s + s/2; const rMax = Math.hypot(state.cols*s, state.rows*s)*0.7; const r = Math.max(0, Math.min(rMax, rMax*collapse.t)); ctx.save(); const g = ctx.createRadialGradient(cx, cy, Math.max(2, r*0.15), cx, cy, r); g.addColorStop(0, 'rgba(10,10,20,0.85)'); g.addColorStop(0.6, 'rgba(30,20,50,0.35)'); g.addColorStop(1, 'rgba(30,20,50,0.0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill(); ctx.restore(); }

  // Render helpers
  function roundRect(ctx, x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); }

  function drawMaze(target=ctx){
    const s = state.size, m = 16; target.save();
    target.fillStyle = '#f9f7ff'; target.fillRect(m-8, m-8, state.cols*s+16, state.rows*s+16);
    for(let y=0;y<state.rows;y++){
      for(let x=0;x<state.cols;x++){
        if(state.grid[y][x]===1){ const px=m+x*s, py=m+y*s; target.fillStyle='#b9b4ff'; roundRect(target, px+2, py+2, s-4, s-4, Math.min(10, s*0.22)); target.fill(); }
      }
    }
    target.restore();
  }

  function drawWormholes(target=ctx){
    if(!state.wormholes.length) return; const s=state.size, m=16; target.save();
    target.strokeStyle='#7c6aff'; target.lineWidth = Math.max(2, s*0.12); target.globalAlpha=0.85;
    for(const wh of state.wormholes){
      if(wh.type==='row'){
        const y = m + wh.row*s + s/2;
        target.beginPath(); target.arc(m-4, y, s*0.45, 0, Math.PI*2); target.stroke();
        target.beginPath(); target.arc(m + state.cols*s + 4, y, s*0.45, 0, Math.PI*2); target.stroke();
      } else if(wh.type==='col'){
        const x = m + wh.col*s + s/2;
        target.beginPath(); target.arc(x, m-4, s*0.45, 0, Math.PI*2); target.stroke();
        target.beginPath(); target.arc(x, m + state.rows*s + 4, s*0.45, 0, Math.PI*2); target.stroke();
      }
    }
    target.globalAlpha=1; target.restore();
  }

  function drawBigEye(x,y,rad, irisColor){
    ctx.save(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill(); ctx.fillStyle=irisColor; ctx.beginPath(); ctx.arc(x, y, rad*0.62, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x + rad*0.1, y + rad*0.1, rad*0.32, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.arc(x - rad*0.2, y - rad*0.25, rad*0.18, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  function drawStarEntity(ent){
    const s=state.size, m=16; const cx = m + ent.x*s + s/2; const cy = m + ent.y*s + s/2; const r = s*0.42;
    const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.3); g.addColorStop(0, 'rgba(132, 94, 247, .95)'); g.addColorStop(1, 'rgba(132, 94, 247, 0.05)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx, cy, r*1.2, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(Math.sin(perfNow()*0.0012)*0.05); ctx.fillStyle = '#a18bff'; ctx.strokeStyle = '#6e5df0'; ctx.lineWidth = 1.5;
    const points=5, R=r, r2=r*0.46; ctx.beginPath(); for(let i=0;i<points*2;i++){ const ang=i*Math.PI/points - Math.PI/2; const rr=(i%2===0)?R:r2; const x=Math.cos(ang)*rr; const y=Math.sin(ang)*rr; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); ctx.stroke();
    drawBigEye(-r*0.22, -r*0.02, r*0.33, '#7c6aff'); drawBigEye( r*0.22, -r*0.02, r*0.33, '#9aa0a8'); ctx.fillStyle='#5a4dbb'; ctx.beginPath(); ctx.arc(0, r*0.22, r*0.12, 0, Math.PI, false); ctx.fill(); ctx.restore();
  }

  function drawSingularityEntity(ent){
    const s=state.size, m=16; const cx = m + ent.x*s + s/2; const cy = m + ent.y*s + s/2; const r = s*0.5;
    ctx.save(); ctx.translate(cx,cy);
    // Escalado si est√° teletransportando (encoge/aparece)
    let scale = 1;
    if(state.teleport){
      const tt = Math.min(1, Math.max(0, state.teleport.t));
      const ease = tt*tt*(3 - 2*tt); // smoothstep
      scale = (state.teleport.phase === 'out') ? (1 - ease) : Math.max(0.001, ease);
    }
    ctx.scale(scale, scale);
    const tone = Math.floor(40 + ent.darkness*40);
    const core = ctx.createRadialGradient(0,0,r*0.1, 0,0,r*1.2);
    core.addColorStop(0, `rgba(${tone},${tone},${tone},1)`);
    core.addColorStop(1, `rgba(20,15,35,0.95)`);
    ctx.fillStyle = core; ctx.beginPath(); ctx.arc(0,0,r*0.95,0,Math.PI*2); ctx.fill();
    ctx.rotate(0.25);
    ctx.strokeStyle = `rgba(${120+ent.darkness*60|0}, ${90+ent.darkness*30|0}, 255, .55)`;
    ctx.lineWidth = r*0.35; ctx.beginPath(); ctx.ellipse(0,0,r*1.3, r*0.52, 0, 0, Math.PI*2); ctx.stroke();
    ctx.lineWidth = r*0.16; ctx.strokeStyle = `rgba(255,255,255,.35)`; ctx.beginPath(); ctx.ellipse(0,0,r*1.25, r*0.48, 0, 0, Math.PI*2); ctx.stroke();
    ctx.rotate(-0.25);
    ctx.globalAlpha = 0.25; ctx.fillStyle = '#8b7cff'; ctx.beginPath(); ctx.arc(0,0,r*1.2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.restore();
  }

  function drawParticles(){
    const s = state.size, m=16; ctx.save();
    for(const p of state.particles){ const alpha = clamp(p.life, 0, 1); ctx.globalAlpha = alpha; const px = m + p.x*s + s/2; const py = m + p.y*s + s/2; drawHeart(px, py, s*0.18, p.color || '#ff7aa8'); }
    ctx.globalAlpha = 1; ctx.restore();
  }
  function drawHeart(x, y, r, color){ ctx.save(); ctx.translate(x,y); ctx.rotate(-0.2 + Math.sin(perfNow()*0.002 + x*0.01)*0.02); ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, r*0.7); ctx.bezierCurveTo(r, r*0.1, r*0.9, -r*0.6, 0, -r*0.2); ctx.bezierCurveTo(-r*0.9, -r*0.6, -r, r*0.1, 0, r*0.7); ctx.fill(); ctx.restore(); }

  // Loop
  let last = performance.now();
  function loop(){ if(!state.running){ requestAnimationFrame(loop); return; } const now=performance.now(); const dt=(now-last)/1000; last=now; update(dt); render(); requestAnimationFrame(loop); }

  function update(dt){
    if(state.gameOver||state.victory) return;
    const cfg = LEVELS[state.levelIndex];

    // Entrada + giro deseado
    const want = desiredDir(); if(want[0]||want[1]) state.star.next = want;
    tryTurn(state.star, state.star.next);

    // avanzar estrella (suavizado y colisi√≥n sin salto)
    const _sx = state.star.x, _sy = state.star.y;
    state.star.x += state.star.dir[0]*STAR_SPEED*dt;
    state.star.y += state.star.dir[1]*STAR_SPEED*dt;
    const sNx = Math.round(state.star.x + Math.sign(state.star.dir[0])*0.51);
    const sNy = Math.round(state.star.y + Math.sign(state.star.dir[1])*0.51);
    if(!open(sNx,sNy)) { state.star.x = _sx; state.star.y = _sy; state.star.dir=[0,0]; }
    else { autoCenter(state.star, dt); }
    // wormholes laterales
    maybeWormhole(state.star);

    // Teletransporte de la Singularidad (si est√° activo)
    if(state.teleport){
      const spd = 1/0.25; // 0.25s por fase
      state.teleport.t += dt*spd;
      if(state.teleport.t >= 1){
        if(state.teleport.phase === 'out'){
          state.saturn.x = state.teleport.to.x;
          state.saturn.y = state.teleport.to.y;
          state.teleport.phase = 'in';
          state.teleport.t = 0;
          for(let i=0;i<8;i++) spawnHeart(state.saturn.x, state.saturn.y, '#a38bff');
          Audio.lightning();
        } else {
          state.teleport = null;
        }
      }
    }

    // IA de la Singularidad (no se mueve durante teletransporte)
    if(!state.teleport) saturnLogic(dt);

    // Temporizador / oscuridad
    state.angerTime = Math.max(0, state.angerTime - dt);
    const t = 1 - (state.angerTime / state.angerMax); state.saturn.darkness = clamp(t,0,1);

    // Besitos
    if(!state.teleport && distance(state.star, state.saturn) <= KISS_NEAR){
      state.nearMs += dt*1000; spawnHeart((state.star.x+state.saturn.x)/2, (state.star.y+state.saturn.y)/2, '#ff98c7');
      if(state.nearMs >= KISS_CHARGE_MS){
        state.nearMs = 0; state.kisses++;
        for(let i=0;i<6;i++) spawnHeart(state.saturn.x, state.saturn.y, '#ff76b2');
        state.angerTime = state.angerMax; // recarga tiempo
        Audio.kiss();
        // Preparar teletransporte: lejos de la estrella
        const from = { x: state.saturn.x, y: state.saturn.y };
        const dst = farthestFrom(state.grid, state.cols, state.rows, Math.round(state.star.x), Math.round(state.star.y));
        state.teleport = { phase: 'out', t: 0, from, to: dst };
        state.saturn.dir = [0,0];
      }
    } else { state.nearMs = Math.max(0, state.nearMs - dt*250); }

    // Fin de nivel
    if(state.kisses >= KISSES_PER_LEVEL){
      for(let i=0;i<10;i++) spawnHeart(state.star.x, state.star.y, '#9df7c7');
      for(let i=0;i<10;i++) spawnHeart(state.saturn.x, state.saturn.y, '#9df7c7');
      if(state.levelIndex < LEVELS.length-1){
        resetLevel(state.levelIndex+1);
      } else {
        state.victory = true; Audio.win();
        // Apagar m√∫sica al ganar
        if(bgm){ try{ bgm.pause(); bgm.currentTime = 0; } catch(e){} }
        state.bgmOn = false; updateHUD();
        showEndCard('¬°Ganaste! Amor por siempre');
      }
    }

    // Colapso al agotar tiempo
    if(state.angerTime <= 0 && !collapse) triggerCollapse();
    if(collapse){
      collapse.t += dt*1.8;
      if(collapse.t >= 1){
        state.lives--; updateHUD();
        state.kisses = Math.max(0, state.kisses - 1);
        state.angerTime = state.angerMax; state.saturn.darkness = 0; collapse = null;
        state.star.x = 1; state.star.y = 1; state.star.dir=[0,0];
        if(state.lives <= 0){
          state.gameOver = true;
          // Apagar m√∫sica al terminar
          if(bgm){ try{ bgm.pause(); bgm.currentTime = 0; } catch(e){} }
          state.bgmOn = false; updateHUD();
          showEndCard('Juego terminado');
        }
      }
    }

    updateParticles(dt); updateHUD();
  }

  function render(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawMaze(); drawWormholes();

    // Efecto de lente alrededor de la Singularidad cuando la estrella pasa cerca
    (function drawSingularityLens(){
      if(!state.cols || !state.rows) return;
      const d = distance(state.star, state.saturn);
      const proximity = clamp(1 - d / (KISS_NEAR*1.8), 0, 1);
      if(proximity > 0 && !state.nearLens){ try{ Audio.distort('near'); }catch(e){} state.nearLens = true; }
      if(proximity <= 0){ state.nearLens = false; return; }
      const s = state.size, m = 16;
      const cx = m + state.saturn.x*s + s/2;
      const cy = m + state.saturn.y*s + s/2;
      const r = s * (2.0 + 3.0*proximity);
      const k = 1 + (0.06 + 0.08*proximity); // fuerza de lente (magnificaci√≥n suave)

      const sx = Math.max(0, Math.floor(cx - r));
      const sy = Math.max(0, Math.floor(cy - r));
      const sw = Math.min(canvas.width - sx, Math.ceil(r*2));
      const sh = Math.min(canvas.height - sy, Math.ceil(r*2));
      if(sw<=0 || sh<=0) return;

      lensCanvas.width = sw; lensCanvas.height = sh;
      lensCtx.clearRect(0,0,sw,sh);
      // copiar regi√≥n circular a buffer
      lensCtx.save();
      lensCtx.beginPath(); lensCtx.arc(sw/2, sh/2, Math.min(sw,sh)/2, 0, Math.PI*2); lensCtx.clip();
      lensCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
      lensCtx.restore();

      // dibujarla de vuelta con ligera magnificaci√≥n dentro de un recorte circular
      ctx.save();
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.clip();
      const dw = sw * k, dh = sh * k;
      ctx.drawImage(lensCanvas, cx - dw/2, cy - dh/2, dw, dh);
      ctx.restore();
    })();
    // Entidades y part√≠culas por encima (no distorsionadas)
    drawParticles(); drawStarEntity(state.star); drawSingularityEntity(state.saturn);
    const m=16, s=state.size; const w = state.cols*s, x=m, y = m + state.rows*s + 2; const pct = state.angerTime / state.angerMax; const barW = clamp(pct, 0, 1)*w;
    ctx.fillStyle = '#ffffffaa'; ctx.fillRect(x, y, w, 10); ctx.fillStyle = pct>0.5? '#9ef5d3' : (pct>0.25? '#ffd87a' : '#ff8aa3'); ctx.fillRect(x, y, barW, 10);
    drawCollapse();
    if(state.gameOver){ drawCenterText('Juego terminado üòµ', '#ff6b9d'); }
    if(state.victory){ drawCenterText('¬°Ganaste! Amor por siempre üíñ', '#44cc99'); }
  }

  function drawCenterText(text, color){ ctx.save(); ctx.fillStyle = '#ffffffcc'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle = color; ctx.font = '700 38px ui-sans-serif, system-ui, Segoe UI'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, canvas.width/2, canvas.height/2); ctx.restore(); }
  function showEndCard(message){
    if(!overlay) return;
    overlay.style.display = 'grid';
    overlay.innerHTML = '<div class="card"><h2>'+message+'</h2><p class="legend">Pulsa R o clic para reiniciar</p><div class="btn" id="restartBtn">Reiniciar</div></div>';
    const rb = document.getElementById('restartBtn');
    if(rb) rb.addEventListener('click', start);
  }

  function start(){
    state = { ...state, lives: MAX_LIVES, levelIndex: 0, gameOver:false, victory:false, running:true };
    resetLevel(0);
    overlay.style.display = 'none';
    // M√∫sica de fondo (mp3)
    if(bgm){
      try {
        bgm.volume = 0.35;
        if(state.bgmOn) bgm.play();
      } catch(e){}
    }
  }
  startBtn.addEventListener('click', start);
  // Toggle de audio
  if(audioToggle){
    audioToggle.addEventListener('click', () => {
      state.bgmOn = !state.bgmOn;
      if(bgm){
        try{
          if(state.bgmOn){ bgm.play(); }
          else { bgm.pause(); }
        }catch(e){}
      }
      updateHUD();
    });
  }

  // Reinicio r√°pido con tecla R o clic en el canvas
  window.addEventListener('keydown', (e) => {
    const k = (e.key||'').toLowerCase();
    if((state.gameOver||state.victory) && k==='r'){
      e.preventDefault(); start();
    }
  });
  canvas.addEventListener('click', () => { if(state.gameOver||state.victory) start(); });

  function fitCanvas(){ const maxW = Math.min(window.innerWidth - 40, 1100); const maxH = Math.min(window.innerHeight - 60, 800); canvas.width = clamp(Math.floor(maxW/2)*2, 640, 1280); canvas.height = clamp(Math.floor(maxH/2)*2, 480, 900); if(state.running) resetLevel(state.levelIndex); }
  window.addEventListener('resize', fitCanvas); fitCanvas(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
