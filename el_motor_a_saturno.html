<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>‚≠êü™ê La Estrella y Saturno ‚Äî Kawaii Maze (v3)</title>
  <style>
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 700px at 50% 30%, #f7f0ff, #e9e6ff 50%, #dfe6ff); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #wrap { display: grid; place-items: center; height: 100%; }
    #hud { position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; }
    .topbar { display:flex; gap:16px; align-items:center; padding: 10px 14px; }
    .pill { background: #ffffffcc; border: 1px solid #00000010; box-shadow: 0 4px 18px #00000012; border-radius: 999px; padding: 6px 12px; font-weight: 700; }
    canvas { display:block; background: linear-gradient(#fdfbff, #f3f2ff); border-radius: 18px; box-shadow: 0 20px 60px #4541a022, inset 0 0 0 1px #00000010; }
    #overlay { position:absolute; inset:0; display:grid; place-items:center; background: linear-gradient(#ffffffcc, #fff0); backdrop-filter: blur(2px); }
    #overlay .card { background:#fff; border-radius:18px; padding:18px 20px; box-shadow: 0 12px 40px #0003; max-width: 780px; text-align:center; }
    .btn { display:inline-block; margin-top:10px; padding:10px 16px; border-radius:12px; background:#6b5bff; color:#fff; font-weight:800; letter-spacing:.3px; cursor:pointer; user-select:none; }
    .btn:active{ transform: translateY(1px); }
    .legend { font-size: 14px; opacity: .75; line-height: 1.35; }
    .mini { font-size: 12px; opacity: .6; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="640" aria-label="Kawaii Star & Saturn Game"></canvas>
    <div id="hud" aria-hidden="true">
      <div class="topbar">
        <div id="lives" class="pill" title="Vidas">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="level" class="pill" title="Nivel">Nivel 1 / 6</div>
        <div id="kisses" class="pill" title="Besitos">Besitos: 0 / 3</div>
        <div id="timer" class="pill" title="Temporizador">Tiempo: 00.0s</div>
      </div>
    </div>
    <div id="overlay">
      <div class="card">
        <h1>‚≠êü™ê La Estrella y Saturno ‚Äî Kawaii Maze</h1>
        <p>La Estrella (Nova) quiere dar <strong>3 besitos</strong> a <strong>Saturno (Lauren)</strong> en cada nivel. El laberinto es estilo <em>Pac‚ÄëMan</em>: <strong>sin callejones sin salida</strong> y con t√∫neles laterales.</p>
        <p class="legend"><strong>Controles:</strong> Mueve a la Estrella con <strong>WASD</strong> o <strong>Flechas</strong>. Ac√©rcate a Saturno para cargar besitos (se cuentan autom√°ticamente).<br/>Si tarda mucho, Saturno se oscurece y lanza un rayo ‚ö°: pierdes 1 vida (tienes 3). Completa 6 niveles.</p>
        <div class="btn" id="startBtn">Comenzar</div>
        <p class="mini">v3: laberinto trenzado (sin dead‚Äëends) + Saturno con anillos + freno cercano</p>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudLives = document.getElementById('lives');
  const hudLevel = document.getElementById('level');
  const hudKisses = document.getElementById('kisses');
  const hudTimer = document.getElementById('timer');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];

  // --- Game Config ---
  const LEVELS = [
    { cols: 21, rows: 15, anger: 18, saturnStepMs: 140 },
    { cols: 23, rows: 17, anger: 16, saturnStepMs: 130 },
    { cols: 25, rows: 17, anger: 14, saturnStepMs: 120 },
    { cols: 27, rows: 19, anger: 13, saturnStepMs: 110 },
    { cols: 29, rows: 21, anger: 12, saturnStepMs: 100 },
    { cols: 31, rows: 21, anger: 11, saturnStepMs: 95 },
  ];
  const MOVE_MS = 90; // Star step
  const KISS_NEAR = 1.01; // tiles
  const KISS_CHARGE_MS = 900; // hold near
  const KISSES_PER_LEVEL = 3;
  const MAX_LIVES = 3;

  // --- State ---
  let state = {
    levelIndex: 0,
    lives: MAX_LIVES,
    grid: [],
    cols: 0, rows: 0, size: 28,
    star: {x:1, y:1, moveCooldown:0},
    saturn:{x:0, y:0, darkness:0, moveCooldown:0},
    kisses: 0, nearMs: 0,
    angerTime: 0, angerMax: 0,
    particles: [],
    running: false, gameOver: false, victory: false,
    tunnels: [] // pairs of [y, xLeft, xRight]
  };

  // --- Input ---
  const keys = new Set();
  window.addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); if(['arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) e.preventDefault(); });
  window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

  // --- Maze Generation: perfect maze -> braid (remove dead-ends) + side tunnels ---
  function generateMaze(cols, rows){
    if(cols%2===0) cols++; if(rows%2===0) rows++;
    const grid = Array.from({length: rows}, () => Array(cols).fill(1)); // 1 wall, 0 path
    const stack = []; const start=[1,1]; grid[1][1]=0; stack.push(start);
    const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
    while(stack.length){
      const [cx,cy]=stack[stack.length-1];
      const neigh=[];
      for(const [dx,dy] of dirs){
        const nx=cx+dx, ny=cy+dy;
        if(nx>0&&ny>0&&nx<cols-1&&ny<rows-1 && grid[ny][nx]===1) neigh.push([nx,ny,dx/2,dy/2]);
      }
      if(neigh.length){
        const [nx,ny,wx,wy]=choice(neigh);
        grid[cy+wy][cx+wx]=0; grid[ny][nx]=0; stack.push([nx,ny]);
      } else stack.pop();
    }
    // Braid: open dead-ends so every path has degree >= 2
    const nb = [[1,0],[-1,0],[0,1],[0,-1]];
    let changed=true;
    while(changed){
      changed=false;
      for(let y=1;y<rows-1;y++){
        for(let x=1;x<cols-1;x++){
          if(grid[y][x]!==0) continue;
          let deg=0; const walls=[];
          for(const [dx,dy] of nb){
            if(grid[y+dy][x+dx]===0) deg++; else walls.push([dx,dy]);
          }
          if(deg<=1 && walls.length){
            const [dx,dy]=choice(walls);
            grid[y+dy][x+dx]=0; // open a wall
            changed=true;
          }
        }
      }
    }
    // Side tunnels like Pac‚ÄëMan
    const tunnelRows=[Math.floor(rows/3), Math.floor(rows*2/3)];
    for(const ry of tunnelRows){
      for(let x=0;x<cols;x++){ grid[ry][x]=0; } // carve row corridor
    }
    return {grid, cols, rows, tunnels: tunnelRows.map(y=>[y,0,cols-1])};
  }

  // BFS farthest
  function farthestFrom(grid, cols, rows, sx, sy){
    const q=[[sx,sy]], dist=Array.from({length: rows}, ()=>Array(cols).fill(Infinity));
    dist[sy][sx]=0; let far=[sx,sy,0];
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const [x,y]=q.shift();
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx>=0&&ny>=0&&nx<cols&&ny<rows && grid[ny][nx]===0 && dist[ny][nx]===Infinity){
          dist[ny][nx]=dist[y][x]+1; q.push([nx,ny]);
          if(dist[ny][nx]>far[2]) far=[nx,ny,dist[ny][nx]];
        }
      }
    }
    return {x: far[0], y: far[1]};
  }

  function resetLevel(index){
    const cfg = LEVELS[index];
    const {grid, cols, rows, tunnels} = generateMaze(cfg.cols, cfg.rows);
    const margin = 16; const maxTileW = Math.floor((canvas.width - margin*2) / cols); const maxTileH = Math.floor((canvas.height - margin*2) / rows);
    state.size = Math.max(18, Math.min(maxTileW, maxTileH));
    state.cols = cols; state.rows = rows; state.grid = grid; state.tunnels = tunnels;
    state.star = {x:1, y:1, moveCooldown:0};
    const far = farthestFrom(grid, cols, rows, 1, 1);
    state.saturn = {x: far.x, y: far.y, darkness:0, moveCooldown:0};
    state.kisses = 0; state.nearMs = 0; state.angerMax = cfg.anger; state.angerTime = cfg.anger;
    state.levelIndex = index; state.particles.length = 0;
    updateHUD();
  }

  function updateHUD(){
    hudLives.textContent = '‚ù§'.repeat(state.lives) + 'üñ§'.repeat(MAX_LIVES - state.lives);
    hudLevel.textContent = `Nivel ${state.levelIndex+1} / ${LEVELS.length}`;
    hudKisses.textContent = `Besitos: ${state.kisses} / ${KISSES_PER_LEVEL}`;
    hudTimer.textContent = `Tiempo: ${state.angerTime.toFixed(1)}s`;
  }

  function open(x,y){ return x>=0&&y>=0&&x<state.cols&&y<state.rows && state.grid[y][x]===0; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  // wrap through tunnels on the carved rows
  function maybeTunnel(ent){
    for(const [ry,xL,xR] of state.tunnels){
      if(ent.y===ry){
        if(ent.x<=xL) ent.x=xR-1; else if(ent.x>=xR) ent.x=xL+1;
      }
    }
  }

  function stepEntity(ent, dir){
    const nx = ent.x + dir[0], ny = ent.y + dir[1];
    if(open(nx,ny)){ ent.x = nx; ent.y = ny; maybeTunnel(ent); }
  }

  function starInputDir(){
    const up = keys.has('w') || keys.has('arrowup');
    const dn = keys.has('s') || keys.has('arrowdown');
    const lt = keys.has('a') || keys.has('arrowleft');
    const rt = keys.has('d') || keys.has('arrowright');
    const dir=[0,0]; if(up&&!dn) dir[1]=-1; else if(dn&&!up) dir[1]=1; if(rt&&!lt) dir[0]=1; else if(lt&&!rt) dir[0]=-1; return dir;
  }

  function saturnRunAwayDir(){
    // prefers to increase distance; slows/halts when near to allow kisses
    const near = dist(state.star, state.saturn) <= KISS_NEAR;
    const opts=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const d of dirs){ const nx=state.saturn.x+d[0], ny=state.saturn.y+d[1]; if(open(nx,ny)) opts.push({d, score: Math.hypot(nx - state.star.x, ny - state.star.y)}); }
    if(!opts.length) return [0,0];
    opts.sort((a,b)=>b.score-a.score);
    return near ? [0,0] : opts[0].d; // freno cercano: se queda para que no "salte" sobre la estrella
  }

  // Part√≠culas
  function spawnHeart(x, y, color){
    state.particles.push({ x: x + (Math.random()-.5)*0.3, y: y + (Math.random()-.5)*0.3, vx: (Math.random()-.5)*0.02, vy: -0.03 - Math.random()*0.02, life: 1, color });
  }
  function updateParticles(dt){ for(const p of state.particles){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.life -= 0.0018*dt; } state.particles = state.particles.filter(p=>p.life>0); }

  // Rayo
  let lightning = null;
  function triggerLightning(){
    const path=[]; const segs=7;
    let x=state.saturn.x, y=state.saturn.y; path.push([x,y]);
    for(let i=0;i<segs;i++){ const t=(i+1)/segs; const tx = state.star.x, ty = state.star.y; x += (tx-x)*0.9 + (Math.random()-.5); y += (ty-y)*0.9 + (Math.random()-.5); path.push([x,y]); }
    lightning = {t:0, path};
  }
  function drawLightning(){ if(!lightning) return; const s=state.size, m=16; ctx.save(); ctx.lineWidth = Math.max(2, s*0.15); ctx.lineCap='round'; ctx.shadowColor='#9ff'; ctx.shadowBlur=18; ctx.strokeStyle='#cfffff'; ctx.beginPath(); const L=Math.floor(lightning.t*(lightning.path.length-1))+1; const pts=lightning.path.slice(0,L); for(let i=0;i<pts.length;i++){ const [tx,ty]=pts[i]; const px=m+tx*s+s/2, py=m+ty*s+s/2; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke(); ctx.restore(); }

  // Render
  function roundRect(ctx, x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); }

  function drawMaze(){
    const s = state.size, m = 16; ctx.save();
    ctx.fillStyle = '#f9f7ff'; ctx.fillRect(m-8, m-8, state.cols*s+16, state.rows*s+16);
    for(let y=0;y<state.rows;y++){
      for(let x=0;x<state.cols;x++){
        if(state.grid[y][x]===1){ const px=m+x*s, py=m+y*s; ctx.fillStyle='#b9b4ff'; roundRect(ctx, px+2, py+2, s-4, s-4, Math.min(10, s*0.22)); ctx.fill(); }
      }
    }
    ctx.restore();
  }

  function drawBigEye(x,y,rad, irisColor){
    ctx.save(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill(); ctx.fillStyle=irisColor; ctx.beginPath(); ctx.arc(x, y, rad*0.62, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x + rad*0.1, y + rad*0.1, rad*0.32, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.arc(x - rad*0.2, y - rad*0.25, rad*0.18, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  function drawStarEntity(ent){
    const s=state.size, m=16; const cx = m + ent.x*s + s/2; const cy = m + ent.y*s + s/2; const r = s*0.42;
    const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.3); g.addColorStop(0, 'rgba(132, 94, 247, .95)'); g.addColorStop(1, 'rgba(132, 94, 247, 0.05)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx, cy, r*1.2, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(Math.sin(perfNow()*0.0012)*0.05); ctx.fillStyle = '#a18bff'; ctx.strokeStyle = '#6e5df0'; ctx.lineWidth = 1.5;
    const points=5, R=r, r2=r*0.46; ctx.beginPath(); for(let i=0;i<points*2;i++){ const ang=i*Math.PI/points - Math.PI/2; const rr=(i%2===0)?R:r2; const x=Math.cos(ang)*rr; const y=Math.sin(ang)*rr; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); ctx.stroke();
    drawBigEye(-r*0.22, -r*0.02, r*0.33, '#7c6aff'); drawBigEye( r*0.22, -r*0.02, r*0.33, '#9aa0a8'); ctx.fillStyle='#5a4dbb'; ctx.beginPath(); ctx.arc(0, r*0.22, r*0.12, 0, Math.PI, false); ctx.fill(); ctx.restore();
  }

  function drawSaturnEntity(ent){
    const s=state.size, m=16; const cx = m + ent.x*s + s/2; const cy = m + ent.y*s + s/2; const r = s*0.44;
    ctx.save(); ctx.translate(cx,cy);
    // body gradient affected by darkness
    const tone = 255 - Math.floor(ent.darkness*120);
    const grd = ctx.createRadialGradient(0,0,r*0.2, 0,0,r*1.1);
    grd.addColorStop(0, `rgba(${tone},${tone-10},${tone},1)`);
    grd.addColorStop(1, `rgba(${tone-40},${tone-50},${tone-60},1)`);
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    // rings
    ctx.rotate(0.25);
    ctx.strokeStyle = `rgba(${160-ent.darkness*80}, ${180-ent.darkness*80}, 255, .9)`;
    ctx.lineWidth = r*0.35; ctx.beginPath(); ctx.ellipse(0,0,r*1.25, r*0.55, 0, 0, Math.PI*2); ctx.stroke();
    ctx.lineWidth = r*0.18; ctx.strokeStyle = `rgba(255,255,255,.85)`; ctx.beginPath(); ctx.ellipse(0,0,r*1.22, r*0.5, 0, 0, Math.PI*2); ctx.stroke();
    ctx.rotate(-0.25);
    // eyes mega grandes (verde)
    drawBigEye(-r*0.22, -r*0.05, r*0.36, `hsl(145deg ${55-Math.min(40, ent.darkness*40)}% 45%)`);
    drawBigEye( r*0.22, -r*0.05, r*0.36, `hsl(145deg ${55-Math.min(40, ent.darkness*40)}% 45%)`);
    // smile
    ctx.strokeStyle = `rgba(${50-ent.darkness*30}, ${80-ent.darkness*40}, ${60-ent.darkness*30}, 1)`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, r*0.25, r*0.22, 0.15*Math.PI, 0.85*Math.PI); ctx.stroke();
    ctx.restore();
  }

  function drawParticles(){
    const s = state.size, m=16; ctx.save();
    for(const p of state.particles){ const alpha = clamp(p.life, 0, 1); ctx.globalAlpha = alpha; const px = m + p.x*s + s/2; const py = m + p.y*s + s/2; drawHeart(px, py, s*0.18, p.color || '#ff7aa8'); }
    ctx.globalAlpha = 1; ctx.restore();
  }
  function drawHeart(x, y, r, color){ ctx.save(); ctx.translate(x,y); ctx.rotate(-0.2 + Math.sin(perfNow()*0.002 + x*0.01)*0.02); ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, r*0.7); ctx.bezierCurveTo(r, r*0.1, r*0.9, -r*0.6, 0, -r*0.2); ctx.bezierCurveTo(-r*0.9, -r*0.6, -r, r*0.1, 0, r*0.7); ctx.fill(); ctx.restore(); }
  function perfNow(){ return performance.now(); }

  // Loop
  let last = performance.now(); function loop(){ if(!state.running){ requestAnimationFrame(loop); return; } const now=performance.now(); const dt=now-last; last=now; update(dt/16.67); render(); requestAnimationFrame(loop); }

  function update(dt){
    if(state.gameOver||state.victory) return;
    const cfg = LEVELS[state.levelIndex];

    // star
    state.star.moveCooldown -= dt*16.67;
    if(state.star.moveCooldown <= 0){ const dir = starInputDir(); if(dir[0]||dir[1]){ stepEntity(state.star, dir); state.star.moveCooldown = MOVE_MS; } }

    // saturn (with near slowdown)
    state.saturn.moveCooldown -= dt*16.67;
    if(state.saturn.moveCooldown <= 0){ const dir = saturnRunAwayDir(); stepEntity(state.saturn, dir); state.saturn.moveCooldown = cfg.saturnStepMs * (dist(state.star,state.saturn)<=KISS_NEAR? 2.2 : 1); }

    // anger/darkness
    state.angerTime -= dt*0.01667; state.angerTime = Math.max(0, state.angerTime); const t = 1 - (state.angerTime / state.angerMax); state.saturn.darkness = t;

    // kisses
    if(dist(state.star, state.saturn) <= KISS_NEAR){ state.nearMs += dt*16.67; spawnHeart((state.star.x+state.saturn.x)/2, (state.star.y+state.saturn.y)/2, '#ff98c7'); if(state.nearMs >= KISS_CHARGE_MS){ state.nearMs = 0; state.kisses++; for(let i=0;i<6;i++) spawnHeart(state.saturn.x, state.saturn.y, '#ff76b2'); state.angerTime = state.angerMax; }} else { state.nearMs = Math.max(0, state.nearMs - dt*10); }

    if(state.kisses >= KISSES_PER_LEVEL){ for(let i=0;i<10;i++) spawnHeart(state.star.x, state.star.y, '#9df7c7'); for(let i=0;i<10;i++) spawnHeart(state.saturn.x, state.saturn.y, '#9df7c7'); if(state.levelIndex < LEVELS.length-1){ resetLevel(state.levelIndex+1); } else { state.victory = true; } }

    if(state.angerTime <= 0 && !lightning) triggerLightning();
    if(lightning){ lightning.t += dt*0.08; if(lightning.t >= 1){ state.lives--; updateHUD(); state.kisses = Math.max(0, state.kisses - 1); state.angerTime = state.angerMax; state.saturn.darkness = 0; lightning = null; state.star.x = 1; state.star.y = 1; if(state.lives <= 0){ state.gameOver = true; } } }

    updateParticles(dt); updateHUD();
  }

  function render(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawMaze(); drawParticles(); drawStarEntity(state.star); drawSaturnEntity(state.saturn);
    const m=16, s=state.size; const w = state.cols*s, x=m, y = m + state.rows*s + 8; const pct = state.angerTime / state.angerMax; const barW = clamp(pct, 0, 1)*w;
    ctx.fillStyle = '#ffffffaa'; ctx.fillRect(x, y, w, 10); ctx.fillStyle = pct>0.5? '#9ef5d3' : (pct>0.25? '#ffd87a' : '#ff8aa3'); ctx.fillRect(x, y, barW, 10);
    drawLightning();
    if(state.gameOver){ drawCenterText('Juego terminado üíî', '#ff6b9d'); }
    if(state.victory){ drawCenterText('¬°Ganaste! Amor por siempre üíö‚ú®', '#44cc99'); }
  }

  function drawCenterText(text, color){ ctx.save(); ctx.fillStyle = '#ffffffcc'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle = color; ctx.font = '700 38px ui-sans-serif, system-ui, Segoe UI'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, canvas.width/2, canvas.height/2); ctx.restore(); }

  function start(){ state = { ...state, lives: MAX_LIVES, levelIndex: 0, gameOver:false, victory:false, running:true }; resetLevel(0); overlay.style.display = 'none'; }
  document.getElementById('startBtn').addEventListener('click', start);

  function fitCanvas(){ const maxW = Math.min(window.innerWidth - 40, 1100); const maxH = Math.min(window.innerHeight - 60, 800); canvas.width = clamp(Math.floor(maxW/2)*2, 640, 1280); canvas.height = clamp(Math.floor(maxH/2)*2, 480, 900); if(state.running) resetLevel(state.levelIndex); }
  window.addEventListener('resize', fitCanvas); fitCanvas(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
